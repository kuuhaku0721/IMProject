// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base.pb.h"
// @@protoc_insertion_point(includes)

namespace tms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class UTargetSelfparam;
class UserTargets;
class UserPrivateInfo;
class UserInfo;
class UserInfo_Old;
class UserOnlineInfo;
class LoginInfo;
class RegisterInfo;
class UserInfoReq;
class TargetsQuery;
class UpdateUserInfo;
class TargetsAdd;
class UpdateTargetInfo;
class UserInfoNotify;
class TargetsAddNotify;
class TargetsNotify;
class UserOnlineNotify;
class UserLoginFlag;
class UserLoginFlagList;
class ChatUser;

enum UserInfoReq_cmd {
  UserInfoReq_cmd_PublicInfo = 0,
  UserInfoReq_cmd_UserTargets = 1,
  UserInfoReq_cmd_UserPrivateInfo = 2,
  UserInfoReq_cmd_UserInfo = 3,
  UserInfoReq_cmd_UserInfo_Old = 4
};
bool UserInfoReq_cmd_IsValid(int value);
const UserInfoReq_cmd UserInfoReq_cmd_cmd_MIN = UserInfoReq_cmd_PublicInfo;
const UserInfoReq_cmd UserInfoReq_cmd_cmd_MAX = UserInfoReq_cmd_UserInfo_Old;
const int UserInfoReq_cmd_cmd_ARRAYSIZE = UserInfoReq_cmd_cmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserInfoReq_cmd_descriptor();
inline const ::std::string& UserInfoReq_cmd_Name(UserInfoReq_cmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserInfoReq_cmd_descriptor(), value);
}
inline bool UserInfoReq_cmd_Parse(
    const ::std::string& name, UserInfoReq_cmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserInfoReq_cmd>(
    UserInfoReq_cmd_descriptor(), name, value);
}
enum TargetsAdd_cmd {
  TargetsAdd_cmd_Apply = 0,
  TargetsAdd_cmd_Applied = 1,
  TargetsAdd_cmd_Agree = 2,
  TargetsAdd_cmd_Agreed = 3,
  TargetsAdd_cmd_Refuse = 4,
  TargetsAdd_cmd_Refused = 5,
  TargetsAdd_cmd_Delete = 6,
  TargetsAdd_cmd_Deleted = 7,
  TargetsAdd_cmd_Fail = 8
};
bool TargetsAdd_cmd_IsValid(int value);
const TargetsAdd_cmd TargetsAdd_cmd_cmd_MIN = TargetsAdd_cmd_Apply;
const TargetsAdd_cmd TargetsAdd_cmd_cmd_MAX = TargetsAdd_cmd_Fail;
const int TargetsAdd_cmd_cmd_ARRAYSIZE = TargetsAdd_cmd_cmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* TargetsAdd_cmd_descriptor();
inline const ::std::string& TargetsAdd_cmd_Name(TargetsAdd_cmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    TargetsAdd_cmd_descriptor(), value);
}
inline bool TargetsAdd_cmd_Parse(
    const ::std::string& name, TargetsAdd_cmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TargetsAdd_cmd>(
    TargetsAdd_cmd_descriptor(), name, value);
}
enum OnlineState {
  OnlineState_Offline = 0,
  OnlineState_Online = 1
};
bool OnlineState_IsValid(int value);
const OnlineState OnlineState_MIN = OnlineState_Offline;
const OnlineState OnlineState_MAX = OnlineState_Online;
const int OnlineState_ARRAYSIZE = OnlineState_MAX + 1;

const ::google::protobuf::EnumDescriptor* OnlineState_descriptor();
inline const ::std::string& OnlineState_Name(OnlineState value) {
  return ::google::protobuf::internal::NameOfEnum(
    OnlineState_descriptor(), value);
}
inline bool OnlineState_Parse(
    const ::std::string& name, OnlineState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OnlineState>(
    OnlineState_descriptor(), name, value);
}
// ===================================================================

class UTargetSelfparam : public ::google::protobuf::Message {
 public:
  UTargetSelfparam();
  virtual ~UTargetSelfparam();

  UTargetSelfparam(const UTargetSelfparam& from);

  inline UTargetSelfparam& operator=(const UTargetSelfparam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UTargetSelfparam& default_instance();

  void Swap(UTargetSelfparam* other);

  // implements Message ----------------------------------------------

  UTargetSelfparam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UTargetSelfparam& from);
  void MergeFrom(const UTargetSelfparam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strNickName = 1;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 1;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const char* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // @@protoc_insertion_point(class_scope:tms.UTargetSelfparam)
 private:
  inline void set_has_strnickname();
  inline void clear_has_strnickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strnickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UTargetSelfparam* default_instance_;
};
// -------------------------------------------------------------------

class UserTargets : public ::google::protobuf::Message {
 public:
  UserTargets();
  virtual ~UserTargets();

  UserTargets(const UserTargets& from);

  inline UserTargets& operator=(const UserTargets& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTargets& default_instance();

  void Swap(UserTargets* other);

  // implements Message ----------------------------------------------

  UserTargets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserTargets& from);
  void MergeFrom(const UserTargets& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.UTarget UTargets = 1;
  inline int utargets_size() const;
  inline void clear_utargets();
  static const int kUTargetsFieldNumber = 1;
  inline const ::tms::UTarget& utargets(int index) const;
  inline ::tms::UTarget* mutable_utargets(int index);
  inline ::tms::UTarget* add_utargets();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::UTarget >&
      utargets() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::UTarget >*
      mutable_utargets();

  // @@protoc_insertion_point(class_scope:tms.UserTargets)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::UTarget > utargets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserTargets* default_instance_;
};
// -------------------------------------------------------------------

class UserPrivateInfo : public ::google::protobuf::Message {
 public:
  UserPrivateInfo();
  virtual ~UserPrivateInfo();

  UserPrivateInfo(const UserPrivateInfo& from);

  inline UserPrivateInfo& operator=(const UserPrivateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPrivateInfo& default_instance();

  void Swap(UserPrivateInfo* other);

  // implements Message ----------------------------------------------

  UserPrivateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserPrivateInfo& from);
  void MergeFrom(const UserPrivateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 nGender = 1 [default = 0];
  inline bool has_ngender() const;
  inline void clear_ngender();
  static const int kNGenderFieldNumber = 1;
  inline ::google::protobuf::uint32 ngender() const;
  inline void set_ngender(::google::protobuf::uint32 value);

  // optional uint32 uBirthday = 2 [default = 0];
  inline bool has_ubirthday() const;
  inline void clear_ubirthday();
  static const int kUBirthdayFieldNumber = 2;
  inline ::google::protobuf::uint32 ubirthday() const;
  inline void set_ubirthday(::google::protobuf::uint32 value);

  // optional uint32 utmRegtime = 3 [default = 0];
  inline bool has_utmregtime() const;
  inline void clear_utmregtime();
  static const int kUtmRegtimeFieldNumber = 3;
  inline ::google::protobuf::uint32 utmregtime() const;
  inline void set_utmregtime(::google::protobuf::uint32 value);

  // optional uint32 nClientType = 4 [default = 0];
  inline bool has_nclienttype() const;
  inline void clear_nclienttype();
  static const int kNClientTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 nclienttype() const;
  inline void set_nclienttype(::google::protobuf::uint32 value);

  // optional string strSigature = 5;
  inline bool has_strsigature() const;
  inline void clear_strsigature();
  static const int kStrSigatureFieldNumber = 5;
  inline const ::std::string& strsigature() const;
  inline void set_strsigature(const ::std::string& value);
  inline void set_strsigature(const char* value);
  inline void set_strsigature(const char* value, size_t size);
  inline ::std::string* mutable_strsigature();
  inline ::std::string* release_strsigature();
  inline void set_allocated_strsigature(::std::string* strsigature);

  // @@protoc_insertion_point(class_scope:tms.UserPrivateInfo)
 private:
  inline void set_has_ngender();
  inline void clear_has_ngender();
  inline void set_has_ubirthday();
  inline void clear_has_ubirthday();
  inline void set_has_utmregtime();
  inline void clear_has_utmregtime();
  inline void set_has_nclienttype();
  inline void clear_has_nclienttype();
  inline void set_has_strsigature();
  inline void clear_has_strsigature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ngender_;
  ::google::protobuf::uint32 ubirthday_;
  ::google::protobuf::uint32 utmregtime_;
  ::google::protobuf::uint32 nclienttype_;
  ::std::string* strsigature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserPrivateInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tms.TargetInfo TargetInfos = 2;
  inline bool has_targetinfos() const;
  inline void clear_targetinfos();
  static const int kTargetInfosFieldNumber = 2;
  inline const ::tms::TargetInfo& targetinfos() const;
  inline ::tms::TargetInfo* mutable_targetinfos();
  inline ::tms::TargetInfo* release_targetinfos();
  inline void set_allocated_targetinfos(::tms::TargetInfo* targetinfos);

  // optional .tms.UserPrivateInfo PrivateInfos = 3;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 3;
  inline const ::tms::UserPrivateInfo& privateinfos() const;
  inline ::tms::UserPrivateInfo* mutable_privateinfos();
  inline ::tms::UserPrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos);

  // @@protoc_insertion_point(class_scope:tms.UserInfo)
 private:
  inline void set_has_targetinfos();
  inline void clear_has_targetinfos();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::TargetInfo* targetinfos_;
  ::tms::UserPrivateInfo* privateinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo_Old : public ::google::protobuf::Message {
 public:
  UserInfo_Old();
  virtual ~UserInfo_Old();

  UserInfo_Old(const UserInfo_Old& from);

  inline UserInfo_Old& operator=(const UserInfo_Old& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo_Old& default_instance();

  void Swap(UserInfo_Old* other);

  // implements Message ----------------------------------------------

  UserInfo_Old* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo_Old& from);
  void MergeFrom(const UserInfo_Old& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tms.TargetInfo TargetInfos = 1;
  inline bool has_targetinfos() const;
  inline void clear_targetinfos();
  static const int kTargetInfosFieldNumber = 1;
  inline const ::tms::TargetInfo& targetinfos() const;
  inline ::tms::TargetInfo* mutable_targetinfos();
  inline ::tms::TargetInfo* release_targetinfos();
  inline void set_allocated_targetinfos(::tms::TargetInfo* targetinfos);

  // optional .tms.UserPrivateInfo PrivateInfos = 2;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 2;
  inline const ::tms::UserPrivateInfo& privateinfos() const;
  inline ::tms::UserPrivateInfo* mutable_privateinfos();
  inline ::tms::UserPrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos);

  // optional .tms.TargetsNotify TargetsNotifys = 3;
  inline bool has_targetsnotifys() const;
  inline void clear_targetsnotifys();
  static const int kTargetsNotifysFieldNumber = 3;
  inline const ::tms::TargetsNotify& targetsnotifys() const;
  inline ::tms::TargetsNotify* mutable_targetsnotifys();
  inline ::tms::TargetsNotify* release_targetsnotifys();
  inline void set_allocated_targetsnotifys(::tms::TargetsNotify* targetsnotifys);

  // @@protoc_insertion_point(class_scope:tms.UserInfo_Old)
 private:
  inline void set_has_targetinfos();
  inline void clear_has_targetinfos();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();
  inline void set_has_targetsnotifys();
  inline void clear_has_targetsnotifys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::TargetInfo* targetinfos_;
  ::tms::UserPrivateInfo* privateinfos_;
  ::tms::TargetsNotify* targetsnotifys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserInfo_Old* default_instance_;
};
// -------------------------------------------------------------------

class UserOnlineInfo : public ::google::protobuf::Message {
 public:
  UserOnlineInfo();
  virtual ~UserOnlineInfo();

  UserOnlineInfo(const UserOnlineInfo& from);

  inline UserOnlineInfo& operator=(const UserOnlineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOnlineInfo& default_instance();

  void Swap(UserOnlineInfo* other);

  // implements Message ----------------------------------------------

  UserOnlineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOnlineInfo& from);
  void MergeFrom(const UserOnlineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uAccountID = 1 [default = 0];
  inline bool has_uaccountid() const;
  inline void clear_uaccountid();
  static const int kUAccountIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uaccountid() const;
  inline void set_uaccountid(::google::protobuf::uint32 value);

  // required uint32 uLoginFlag = 2 [default = 0];
  inline bool has_uloginflag() const;
  inline void clear_uloginflag();
  static const int kULoginFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 uloginflag() const;
  inline void set_uloginflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.UserOnlineInfo)
 private:
  inline void set_has_uaccountid();
  inline void clear_has_uaccountid();
  inline void set_has_uloginflag();
  inline void clear_has_uloginflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uaccountid_;
  ::google::protobuf::uint32 uloginflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserOnlineInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginInfo : public ::google::protobuf::Message {
 public:
  LoginInfo();
  virtual ~LoginInfo();

  LoginInfo(const LoginInfo& from);

  inline LoginInfo& operator=(const LoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginInfo& default_instance();

  void Swap(LoginInfo* other);

  // implements Message ----------------------------------------------

  LoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginInfo& from);
  void MergeFrom(const LoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strAccountNo = 1;
  inline bool has_straccountno() const;
  inline void clear_straccountno();
  static const int kStrAccountNoFieldNumber = 1;
  inline const ::std::string& straccountno() const;
  inline void set_straccountno(const ::std::string& value);
  inline void set_straccountno(const char* value);
  inline void set_straccountno(const char* value, size_t size);
  inline ::std::string* mutable_straccountno();
  inline ::std::string* release_straccountno();
  inline void set_allocated_straccountno(::std::string* straccountno);

  // required string strPasswd = 2;
  inline bool has_strpasswd() const;
  inline void clear_strpasswd();
  static const int kStrPasswdFieldNumber = 2;
  inline const ::std::string& strpasswd() const;
  inline void set_strpasswd(const ::std::string& value);
  inline void set_strpasswd(const char* value);
  inline void set_strpasswd(const char* value, size_t size);
  inline ::std::string* mutable_strpasswd();
  inline ::std::string* release_strpasswd();
  inline void set_allocated_strpasswd(::std::string* strpasswd);

  // optional uint32 uLoginFlags = 3 [default = 0];
  inline bool has_uloginflags() const;
  inline void clear_uloginflags();
  static const int kULoginFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 uloginflags() const;
  inline void set_uloginflags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.LoginInfo)
 private:
  inline void set_has_straccountno();
  inline void clear_has_straccountno();
  inline void set_has_strpasswd();
  inline void clear_has_strpasswd();
  inline void set_has_uloginflags();
  inline void clear_has_uloginflags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccountno_;
  ::std::string* strpasswd_;
  ::google::protobuf::uint32 uloginflags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class RegisterInfo : public ::google::protobuf::Message {
 public:
  RegisterInfo();
  virtual ~RegisterInfo();

  RegisterInfo(const RegisterInfo& from);

  inline RegisterInfo& operator=(const RegisterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterInfo& default_instance();

  void Swap(RegisterInfo* other);

  // implements Message ----------------------------------------------

  RegisterInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterInfo& from);
  void MergeFrom(const RegisterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strAccountNo = 1;
  inline bool has_straccountno() const;
  inline void clear_straccountno();
  static const int kStrAccountNoFieldNumber = 1;
  inline const ::std::string& straccountno() const;
  inline void set_straccountno(const ::std::string& value);
  inline void set_straccountno(const char* value);
  inline void set_straccountno(const char* value, size_t size);
  inline ::std::string* mutable_straccountno();
  inline ::std::string* release_straccountno();
  inline void set_allocated_straccountno(::std::string* straccountno);

  // required string strPasswd = 2;
  inline bool has_strpasswd() const;
  inline void clear_strpasswd();
  static const int kStrPasswdFieldNumber = 2;
  inline const ::std::string& strpasswd() const;
  inline void set_strpasswd(const ::std::string& value);
  inline void set_strpasswd(const char* value);
  inline void set_strpasswd(const char* value, size_t size);
  inline ::std::string* mutable_strpasswd();
  inline ::std::string* release_strpasswd();
  inline void set_allocated_strpasswd(::std::string* strpasswd);

  // required string strNickName = 3;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 3;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const char* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // @@protoc_insertion_point(class_scope:tms.RegisterInfo)
 private:
  inline void set_has_straccountno();
  inline void clear_has_straccountno();
  inline void set_has_strpasswd();
  inline void clear_has_strpasswd();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccountno_;
  ::std::string* strpasswd_;
  ::std::string* strnickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static RegisterInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoReq : public ::google::protobuf::Message {
 public:
  UserInfoReq();
  virtual ~UserInfoReq();

  UserInfoReq(const UserInfoReq& from);

  inline UserInfoReq& operator=(const UserInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoReq& default_instance();

  void Swap(UserInfoReq* other);

  // implements Message ----------------------------------------------

  UserInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoReq& from);
  void MergeFrom(const UserInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserInfoReq_cmd cmd;
  static const cmd PublicInfo = UserInfoReq_cmd_PublicInfo;
  static const cmd UserTargets = UserInfoReq_cmd_UserTargets;
  static const cmd UserPrivateInfo = UserInfoReq_cmd_UserPrivateInfo;
  static const cmd UserInfo = UserInfoReq_cmd_UserInfo;
  static const cmd UserInfo_Old = UserInfoReq_cmd_UserInfo_Old;
  static inline bool cmd_IsValid(int value) {
    return UserInfoReq_cmd_IsValid(value);
  }
  static const cmd cmd_MIN =
    UserInfoReq_cmd_cmd_MIN;
  static const cmd cmd_MAX =
    UserInfoReq_cmd_cmd_MAX;
  static const int cmd_ARRAYSIZE =
    UserInfoReq_cmd_cmd_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  cmd_descriptor() {
    return UserInfoReq_cmd_descriptor();
  }
  static inline const ::std::string& cmd_Name(cmd value) {
    return UserInfoReq_cmd_Name(value);
  }
  static inline bool cmd_Parse(const ::std::string& name,
      cmd* value) {
    return UserInfoReq_cmd_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tms.UserInfoReq.cmd ncmd = 1 [default = UserInfo];
  inline bool has_ncmd() const;
  inline void clear_ncmd();
  static const int kNcmdFieldNumber = 1;
  inline ::tms::UserInfoReq_cmd ncmd() const;
  inline void set_ncmd(::tms::UserInfoReq_cmd value);

  // @@protoc_insertion_point(class_scope:tms.UserInfoReq)
 private:
  inline void set_has_ncmd();
  inline void clear_has_ncmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ncmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class TargetsQuery : public ::google::protobuf::Message {
 public:
  TargetsQuery();
  virtual ~TargetsQuery();

  TargetsQuery(const TargetsQuery& from);

  inline TargetsQuery& operator=(const TargetsQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetsQuery& default_instance();

  void Swap(TargetsQuery* other);

  // implements Message ----------------------------------------------

  TargetsQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetsQuery& from);
  void MergeFrom(const TargetsQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strAccountNo = 1;
  inline bool has_straccountno() const;
  inline void clear_straccountno();
  static const int kStrAccountNoFieldNumber = 1;
  inline const ::std::string& straccountno() const;
  inline void set_straccountno(const ::std::string& value);
  inline void set_straccountno(const char* value);
  inline void set_straccountno(const char* value, size_t size);
  inline ::std::string* mutable_straccountno();
  inline ::std::string* release_straccountno();
  inline void set_allocated_straccountno(::std::string* straccountno);

  // required string strNickName = 2;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 2;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const char* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // @@protoc_insertion_point(class_scope:tms.TargetsQuery)
 private:
  inline void set_has_straccountno();
  inline void clear_has_straccountno();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccountno_;
  ::std::string* strnickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TargetsQuery* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserInfo : public ::google::protobuf::Message {
 public:
  UpdateUserInfo();
  virtual ~UpdateUserInfo();

  UpdateUserInfo(const UpdateUserInfo& from);

  inline UpdateUserInfo& operator=(const UpdateUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateUserInfo& default_instance();

  void Swap(UpdateUserInfo* other);

  // implements Message ----------------------------------------------

  UpdateUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateUserInfo& from);
  void MergeFrom(const UpdateUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string strNickName = 1;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 1;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const char* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // optional uint32 nFace = 2 [default = 0];
  inline bool has_nface() const;
  inline void clear_nface();
  static const int kNFaceFieldNumber = 2;
  inline ::google::protobuf::uint32 nface() const;
  inline void set_nface(::google::protobuf::uint32 value);

  // optional .tms.UserPrivateInfo PrivateInfos = 3;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 3;
  inline const ::tms::UserPrivateInfo& privateinfos() const;
  inline ::tms::UserPrivateInfo* mutable_privateinfos();
  inline ::tms::UserPrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos);

  // @@protoc_insertion_point(class_scope:tms.UpdateUserInfo)
 private:
  inline void set_has_strnickname();
  inline void clear_has_strnickname();
  inline void set_has_nface();
  inline void clear_has_nface();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strnickname_;
  ::tms::UserPrivateInfo* privateinfos_;
  ::google::protobuf::uint32 nface_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class TargetsAdd : public ::google::protobuf::Message {
 public:
  TargetsAdd();
  virtual ~TargetsAdd();

  TargetsAdd(const TargetsAdd& from);

  inline TargetsAdd& operator=(const TargetsAdd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetsAdd& default_instance();

  void Swap(TargetsAdd* other);

  // implements Message ----------------------------------------------

  TargetsAdd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetsAdd& from);
  void MergeFrom(const TargetsAdd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TargetsAdd_cmd cmd;
  static const cmd Apply = TargetsAdd_cmd_Apply;
  static const cmd Applied = TargetsAdd_cmd_Applied;
  static const cmd Agree = TargetsAdd_cmd_Agree;
  static const cmd Agreed = TargetsAdd_cmd_Agreed;
  static const cmd Refuse = TargetsAdd_cmd_Refuse;
  static const cmd Refused = TargetsAdd_cmd_Refused;
  static const cmd Delete = TargetsAdd_cmd_Delete;
  static const cmd Deleted = TargetsAdd_cmd_Deleted;
  static const cmd Fail = TargetsAdd_cmd_Fail;
  static inline bool cmd_IsValid(int value) {
    return TargetsAdd_cmd_IsValid(value);
  }
  static const cmd cmd_MIN =
    TargetsAdd_cmd_cmd_MIN;
  static const cmd cmd_MAX =
    TargetsAdd_cmd_cmd_MAX;
  static const int cmd_ARRAYSIZE =
    TargetsAdd_cmd_cmd_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  cmd_descriptor() {
    return TargetsAdd_cmd_descriptor();
  }
  static inline const ::std::string& cmd_Name(cmd value) {
    return TargetsAdd_cmd_Name(value);
  }
  static inline bool cmd_Parse(const ::std::string& name,
      cmd* value) {
    return TargetsAdd_cmd_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required .tms.TargetsAdd.cmd ncmd = 2 [default = Apply];
  inline bool has_ncmd() const;
  inline void clear_ncmd();
  static const int kNcmdFieldNumber = 2;
  inline ::tms::TargetsAdd_cmd ncmd() const;
  inline void set_ncmd(::tms::TargetsAdd_cmd value);

  // @@protoc_insertion_point(class_scope:tms.TargetsAdd)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_ncmd();
  inline void clear_has_ncmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 utargetid_;
  int ncmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TargetsAdd* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTargetInfo : public ::google::protobuf::Message {
 public:
  UpdateTargetInfo();
  virtual ~UpdateTargetInfo();

  UpdateTargetInfo(const UpdateTargetInfo& from);

  inline UpdateTargetInfo& operator=(const UpdateTargetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTargetInfo& default_instance();

  void Swap(UpdateTargetInfo* other);

  // implements Message ----------------------------------------------

  UpdateTargetInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTargetInfo& from);
  void MergeFrom(const UpdateTargetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // optional string strNickName = 2;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 2;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const char* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // optional bytes selfparam = 3;
  inline bool has_selfparam() const;
  inline void clear_selfparam();
  static const int kSelfparamFieldNumber = 3;
  inline const ::std::string& selfparam() const;
  inline void set_selfparam(const ::std::string& value);
  inline void set_selfparam(const char* value);
  inline void set_selfparam(const void* value, size_t size);
  inline ::std::string* mutable_selfparam();
  inline ::std::string* release_selfparam();
  inline void set_allocated_selfparam(::std::string* selfparam);

  // @@protoc_insertion_point(class_scope:tms.UpdateTargetInfo)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();
  inline void set_has_selfparam();
  inline void clear_has_selfparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strnickname_;
  ::std::string* selfparam_;
  ::google::protobuf::uint32 utargetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateTargetInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoNotify : public ::google::protobuf::Message {
 public:
  UserInfoNotify();
  virtual ~UserInfoNotify();

  UserInfoNotify(const UserInfoNotify& from);

  inline UserInfoNotify& operator=(const UserInfoNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoNotify& default_instance();

  void Swap(UserInfoNotify* other);

  // implements Message ----------------------------------------------

  UserInfoNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoNotify& from);
  void MergeFrom(const UserInfoNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uAccountID = 1 [default = 0];
  inline bool has_uaccountid() const;
  inline void clear_uaccountid();
  static const int kUAccountIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uaccountid() const;
  inline void set_uaccountid(::google::protobuf::uint32 value);

  // optional string strAccountNo = 2;
  inline bool has_straccountno() const;
  inline void clear_straccountno();
  static const int kStrAccountNoFieldNumber = 2;
  inline const ::std::string& straccountno() const;
  inline void set_straccountno(const ::std::string& value);
  inline void set_straccountno(const char* value);
  inline void set_straccountno(const char* value, size_t size);
  inline ::std::string* mutable_straccountno();
  inline ::std::string* release_straccountno();
  inline void set_allocated_straccountno(::std::string* straccountno);

  // optional string strNickName = 3;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 3;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const char* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // optional uint32 nFace = 4 [default = 0];
  inline bool has_nface() const;
  inline void clear_nface();
  static const int kNFaceFieldNumber = 4;
  inline ::google::protobuf::uint32 nface() const;
  inline void set_nface(::google::protobuf::uint32 value);

  // optional .tms.UserPrivateInfo PrivateInfos = 5;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 5;
  inline const ::tms::UserPrivateInfo& privateinfos() const;
  inline ::tms::UserPrivateInfo* mutable_privateinfos();
  inline ::tms::UserPrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos);

  // @@protoc_insertion_point(class_scope:tms.UserInfoNotify)
 private:
  inline void set_has_uaccountid();
  inline void clear_has_uaccountid();
  inline void set_has_straccountno();
  inline void clear_has_straccountno();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();
  inline void set_has_nface();
  inline void clear_has_nface();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccountno_;
  ::google::protobuf::uint32 uaccountid_;
  ::google::protobuf::uint32 nface_;
  ::std::string* strnickname_;
  ::tms::UserPrivateInfo* privateinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserInfoNotify* default_instance_;
};
// -------------------------------------------------------------------

class TargetsAddNotify : public ::google::protobuf::Message {
 public:
  TargetsAddNotify();
  virtual ~TargetsAddNotify();

  TargetsAddNotify(const TargetsAddNotify& from);

  inline TargetsAddNotify& operator=(const TargetsAddNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetsAddNotify& default_instance();

  void Swap(TargetsAddNotify* other);

  // implements Message ----------------------------------------------

  TargetsAddNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetsAddNotify& from);
  void MergeFrom(const TargetsAddNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tms.TargetsAdd TargetsAdds = 1;
  inline bool has_targetsadds() const;
  inline void clear_targetsadds();
  static const int kTargetsAddsFieldNumber = 1;
  inline const ::tms::TargetsAdd& targetsadds() const;
  inline ::tms::TargetsAdd* mutable_targetsadds();
  inline ::tms::TargetsAdd* release_targetsadds();
  inline void set_allocated_targetsadds(::tms::TargetsAdd* targetsadds);

  // required .tms.TargetInfo TargetInfos = 3;
  inline bool has_targetinfos() const;
  inline void clear_targetinfos();
  static const int kTargetInfosFieldNumber = 3;
  inline const ::tms::TargetInfo& targetinfos() const;
  inline ::tms::TargetInfo* mutable_targetinfos();
  inline ::tms::TargetInfo* release_targetinfos();
  inline void set_allocated_targetinfos(::tms::TargetInfo* targetinfos);

  // @@protoc_insertion_point(class_scope:tms.TargetsAddNotify)
 private:
  inline void set_has_targetsadds();
  inline void clear_has_targetsadds();
  inline void set_has_targetinfos();
  inline void clear_has_targetinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::TargetsAdd* targetsadds_;
  ::tms::TargetInfo* targetinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TargetsAddNotify* default_instance_;
};
// -------------------------------------------------------------------

class TargetsNotify : public ::google::protobuf::Message {
 public:
  TargetsNotify();
  virtual ~TargetsNotify();

  TargetsNotify(const TargetsNotify& from);

  inline TargetsNotify& operator=(const TargetsNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetsNotify& default_instance();

  void Swap(TargetsNotify* other);

  // implements Message ----------------------------------------------

  TargetsNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetsNotify& from);
  void MergeFrom(const TargetsNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.Targets Targetss = 1;
  inline int targetss_size() const;
  inline void clear_targetss();
  static const int kTargetssFieldNumber = 1;
  inline const ::tms::Targets& targetss(int index) const;
  inline ::tms::Targets* mutable_targetss(int index);
  inline ::tms::Targets* add_targetss();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::Targets >&
      targetss() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::Targets >*
      mutable_targetss();

  // @@protoc_insertion_point(class_scope:tms.TargetsNotify)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::Targets > targetss_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TargetsNotify* default_instance_;
};
// -------------------------------------------------------------------

class UserOnlineNotify : public ::google::protobuf::Message {
 public:
  UserOnlineNotify();
  virtual ~UserOnlineNotify();

  UserOnlineNotify(const UserOnlineNotify& from);

  inline UserOnlineNotify& operator=(const UserOnlineNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOnlineNotify& default_instance();

  void Swap(UserOnlineNotify* other);

  // implements Message ----------------------------------------------

  UserOnlineNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOnlineNotify& from);
  void MergeFrom(const UserOnlineNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uAccountID = 1 [default = 0];
  inline bool has_uaccountid() const;
  inline void clear_uaccountid();
  static const int kUAccountIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uaccountid() const;
  inline void set_uaccountid(::google::protobuf::uint32 value);

  // required uint32 uServerID = 2 [default = 0];
  inline bool has_userverid() const;
  inline void clear_userverid();
  static const int kUServerIDFieldNumber = 2;
  inline ::google::protobuf::uint32 userverid() const;
  inline void set_userverid(::google::protobuf::uint32 value);

  // required uint32 uLoginFlag = 3 [default = 0];
  inline bool has_uloginflag() const;
  inline void clear_uloginflag();
  static const int kULoginFlagFieldNumber = 3;
  inline ::google::protobuf::uint32 uloginflag() const;
  inline void set_uloginflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.UserOnlineNotify)
 private:
  inline void set_has_uaccountid();
  inline void clear_has_uaccountid();
  inline void set_has_userverid();
  inline void clear_has_userverid();
  inline void set_has_uloginflag();
  inline void clear_has_uloginflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uaccountid_;
  ::google::protobuf::uint32 userverid_;
  ::google::protobuf::uint32 uloginflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserOnlineNotify* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginFlag : public ::google::protobuf::Message {
 public:
  UserLoginFlag();
  virtual ~UserLoginFlag();

  UserLoginFlag(const UserLoginFlag& from);

  inline UserLoginFlag& operator=(const UserLoginFlag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginFlag& default_instance();

  void Swap(UserLoginFlag* other);

  // implements Message ----------------------------------------------

  UserLoginFlag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLoginFlag& from);
  void MergeFrom(const UserLoginFlag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uAccountID = 1 [default = 0];
  inline bool has_uaccountid() const;
  inline void clear_uaccountid();
  static const int kUAccountIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uaccountid() const;
  inline void set_uaccountid(::google::protobuf::uint32 value);

  // required uint32 uLoginFlags = 2 [default = 0];
  inline bool has_uloginflags() const;
  inline void clear_uloginflags();
  static const int kULoginFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 uloginflags() const;
  inline void set_uloginflags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.UserLoginFlag)
 private:
  inline void set_has_uaccountid();
  inline void clear_has_uaccountid();
  inline void set_has_uloginflags();
  inline void clear_has_uloginflags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uaccountid_;
  ::google::protobuf::uint32 uloginflags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserLoginFlag* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginFlagList : public ::google::protobuf::Message {
 public:
  UserLoginFlagList();
  virtual ~UserLoginFlagList();

  UserLoginFlagList(const UserLoginFlagList& from);

  inline UserLoginFlagList& operator=(const UserLoginFlagList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginFlagList& default_instance();

  void Swap(UserLoginFlagList* other);

  // implements Message ----------------------------------------------

  UserLoginFlagList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLoginFlagList& from);
  void MergeFrom(const UserLoginFlagList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.UserLoginFlag UserLoginFlags = 1;
  inline int userloginflags_size() const;
  inline void clear_userloginflags();
  static const int kUserLoginFlagsFieldNumber = 1;
  inline const ::tms::UserLoginFlag& userloginflags(int index) const;
  inline ::tms::UserLoginFlag* mutable_userloginflags(int index);
  inline ::tms::UserLoginFlag* add_userloginflags();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::UserLoginFlag >&
      userloginflags() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::UserLoginFlag >*
      mutable_userloginflags();

  // @@protoc_insertion_point(class_scope:tms.UserLoginFlagList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::UserLoginFlag > userloginflags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserLoginFlagList* default_instance_;
};
// -------------------------------------------------------------------

class ChatUser : public ::google::protobuf::Message {
 public:
  ChatUser();
  virtual ~ChatUser();

  ChatUser(const ChatUser& from);

  inline ChatUser& operator=(const ChatUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatUser& default_instance();

  void Swap(ChatUser* other);

  // implements Message ----------------------------------------------

  ChatUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatUser& from);
  void MergeFrom(const ChatUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uAccountID = 1 [default = 0];
  inline bool has_uaccountid() const;
  inline void clear_uaccountid();
  static const int kUAccountIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uaccountid() const;
  inline void set_uaccountid(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required uint32 uRight = 3 [default = 0];
  inline bool has_uright() const;
  inline void clear_uright();
  static const int kURightFieldNumber = 3;
  inline ::google::protobuf::uint32 uright() const;
  inline void set_uright(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.ChatUser)
 private:
  inline void set_has_uaccountid();
  inline void clear_has_uaccountid();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_uright();
  inline void clear_has_uright();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uaccountid_;
  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::uint32 uright_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static ChatUser* default_instance_;
};
// ===================================================================


// ===================================================================

// UTargetSelfparam

// required string strNickName = 1;
inline bool UTargetSelfparam::has_strnickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UTargetSelfparam::set_has_strnickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UTargetSelfparam::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UTargetSelfparam::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& UTargetSelfparam::strnickname() const {
  return *strnickname_;
}
inline void UTargetSelfparam::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UTargetSelfparam::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UTargetSelfparam::set_strnickname(const char* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UTargetSelfparam::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* UTargetSelfparam::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UTargetSelfparam::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserTargets

// repeated .tms.UTarget UTargets = 1;
inline int UserTargets::utargets_size() const {
  return utargets_.size();
}
inline void UserTargets::clear_utargets() {
  utargets_.Clear();
}
inline const ::tms::UTarget& UserTargets::utargets(int index) const {
  return utargets_.Get(index);
}
inline ::tms::UTarget* UserTargets::mutable_utargets(int index) {
  return utargets_.Mutable(index);
}
inline ::tms::UTarget* UserTargets::add_utargets() {
  return utargets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::UTarget >&
UserTargets::utargets() const {
  return utargets_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::UTarget >*
UserTargets::mutable_utargets() {
  return &utargets_;
}

// -------------------------------------------------------------------

// UserPrivateInfo

// optional uint32 nGender = 1 [default = 0];
inline bool UserPrivateInfo::has_ngender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPrivateInfo::set_has_ngender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPrivateInfo::clear_has_ngender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPrivateInfo::clear_ngender() {
  ngender_ = 0u;
  clear_has_ngender();
}
inline ::google::protobuf::uint32 UserPrivateInfo::ngender() const {
  return ngender_;
}
inline void UserPrivateInfo::set_ngender(::google::protobuf::uint32 value) {
  set_has_ngender();
  ngender_ = value;
}

// optional uint32 uBirthday = 2 [default = 0];
inline bool UserPrivateInfo::has_ubirthday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPrivateInfo::set_has_ubirthday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPrivateInfo::clear_has_ubirthday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPrivateInfo::clear_ubirthday() {
  ubirthday_ = 0u;
  clear_has_ubirthday();
}
inline ::google::protobuf::uint32 UserPrivateInfo::ubirthday() const {
  return ubirthday_;
}
inline void UserPrivateInfo::set_ubirthday(::google::protobuf::uint32 value) {
  set_has_ubirthday();
  ubirthday_ = value;
}

// optional uint32 utmRegtime = 3 [default = 0];
inline bool UserPrivateInfo::has_utmregtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPrivateInfo::set_has_utmregtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPrivateInfo::clear_has_utmregtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPrivateInfo::clear_utmregtime() {
  utmregtime_ = 0u;
  clear_has_utmregtime();
}
inline ::google::protobuf::uint32 UserPrivateInfo::utmregtime() const {
  return utmregtime_;
}
inline void UserPrivateInfo::set_utmregtime(::google::protobuf::uint32 value) {
  set_has_utmregtime();
  utmregtime_ = value;
}

// optional uint32 nClientType = 4 [default = 0];
inline bool UserPrivateInfo::has_nclienttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserPrivateInfo::set_has_nclienttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserPrivateInfo::clear_has_nclienttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserPrivateInfo::clear_nclienttype() {
  nclienttype_ = 0u;
  clear_has_nclienttype();
}
inline ::google::protobuf::uint32 UserPrivateInfo::nclienttype() const {
  return nclienttype_;
}
inline void UserPrivateInfo::set_nclienttype(::google::protobuf::uint32 value) {
  set_has_nclienttype();
  nclienttype_ = value;
}

// optional string strSigature = 5;
inline bool UserPrivateInfo::has_strsigature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserPrivateInfo::set_has_strsigature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserPrivateInfo::clear_has_strsigature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserPrivateInfo::clear_strsigature() {
  if (strsigature_ != &::google::protobuf::internal::kEmptyString) {
    strsigature_->clear();
  }
  clear_has_strsigature();
}
inline const ::std::string& UserPrivateInfo::strsigature() const {
  return *strsigature_;
}
inline void UserPrivateInfo::set_strsigature(const ::std::string& value) {
  set_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    strsigature_ = new ::std::string;
  }
  strsigature_->assign(value);
}
inline void UserPrivateInfo::set_strsigature(const char* value) {
  set_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    strsigature_ = new ::std::string;
  }
  strsigature_->assign(value);
}
inline void UserPrivateInfo::set_strsigature(const char* value, size_t size) {
  set_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    strsigature_ = new ::std::string;
  }
  strsigature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strsigature() {
  set_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    strsigature_ = new ::std::string;
  }
  return strsigature_;
}
inline ::std::string* UserPrivateInfo::release_strsigature() {
  clear_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsigature_;
    strsigature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strsigature(::std::string* strsigature) {
  if (strsigature_ != &::google::protobuf::internal::kEmptyString) {
    delete strsigature_;
  }
  if (strsigature) {
    set_has_strsigature();
    strsigature_ = strsigature;
  } else {
    clear_has_strsigature();
    strsigature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfo

// required .tms.TargetInfo TargetInfos = 2;
inline bool UserInfo::has_targetinfos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_targetinfos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_targetinfos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_targetinfos() {
  if (targetinfos_ != NULL) targetinfos_->::tms::TargetInfo::Clear();
  clear_has_targetinfos();
}
inline const ::tms::TargetInfo& UserInfo::targetinfos() const {
  return targetinfos_ != NULL ? *targetinfos_ : *default_instance_->targetinfos_;
}
inline ::tms::TargetInfo* UserInfo::mutable_targetinfos() {
  set_has_targetinfos();
  if (targetinfos_ == NULL) targetinfos_ = new ::tms::TargetInfo;
  return targetinfos_;
}
inline ::tms::TargetInfo* UserInfo::release_targetinfos() {
  clear_has_targetinfos();
  ::tms::TargetInfo* temp = targetinfos_;
  targetinfos_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_targetinfos(::tms::TargetInfo* targetinfos) {
  delete targetinfos_;
  targetinfos_ = targetinfos;
  if (targetinfos) {
    set_has_targetinfos();
  } else {
    clear_has_targetinfos();
  }
}

// optional .tms.UserPrivateInfo PrivateInfos = 3;
inline bool UserInfo::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::UserPrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::UserPrivateInfo& UserInfo::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfo::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::UserPrivateInfo;
  return privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfo::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::UserPrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// -------------------------------------------------------------------

// UserInfo_Old

// required .tms.TargetInfo TargetInfos = 1;
inline bool UserInfo_Old::has_targetinfos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo_Old::set_has_targetinfos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo_Old::clear_has_targetinfos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo_Old::clear_targetinfos() {
  if (targetinfos_ != NULL) targetinfos_->::tms::TargetInfo::Clear();
  clear_has_targetinfos();
}
inline const ::tms::TargetInfo& UserInfo_Old::targetinfos() const {
  return targetinfos_ != NULL ? *targetinfos_ : *default_instance_->targetinfos_;
}
inline ::tms::TargetInfo* UserInfo_Old::mutable_targetinfos() {
  set_has_targetinfos();
  if (targetinfos_ == NULL) targetinfos_ = new ::tms::TargetInfo;
  return targetinfos_;
}
inline ::tms::TargetInfo* UserInfo_Old::release_targetinfos() {
  clear_has_targetinfos();
  ::tms::TargetInfo* temp = targetinfos_;
  targetinfos_ = NULL;
  return temp;
}
inline void UserInfo_Old::set_allocated_targetinfos(::tms::TargetInfo* targetinfos) {
  delete targetinfos_;
  targetinfos_ = targetinfos;
  if (targetinfos) {
    set_has_targetinfos();
  } else {
    clear_has_targetinfos();
  }
}

// optional .tms.UserPrivateInfo PrivateInfos = 2;
inline bool UserInfo_Old::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo_Old::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo_Old::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo_Old::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::UserPrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::UserPrivateInfo& UserInfo_Old::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfo_Old::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::UserPrivateInfo;
  return privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfo_Old::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::UserPrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void UserInfo_Old::set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// optional .tms.TargetsNotify TargetsNotifys = 3;
inline bool UserInfo_Old::has_targetsnotifys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo_Old::set_has_targetsnotifys() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo_Old::clear_has_targetsnotifys() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo_Old::clear_targetsnotifys() {
  if (targetsnotifys_ != NULL) targetsnotifys_->::tms::TargetsNotify::Clear();
  clear_has_targetsnotifys();
}
inline const ::tms::TargetsNotify& UserInfo_Old::targetsnotifys() const {
  return targetsnotifys_ != NULL ? *targetsnotifys_ : *default_instance_->targetsnotifys_;
}
inline ::tms::TargetsNotify* UserInfo_Old::mutable_targetsnotifys() {
  set_has_targetsnotifys();
  if (targetsnotifys_ == NULL) targetsnotifys_ = new ::tms::TargetsNotify;
  return targetsnotifys_;
}
inline ::tms::TargetsNotify* UserInfo_Old::release_targetsnotifys() {
  clear_has_targetsnotifys();
  ::tms::TargetsNotify* temp = targetsnotifys_;
  targetsnotifys_ = NULL;
  return temp;
}
inline void UserInfo_Old::set_allocated_targetsnotifys(::tms::TargetsNotify* targetsnotifys) {
  delete targetsnotifys_;
  targetsnotifys_ = targetsnotifys;
  if (targetsnotifys) {
    set_has_targetsnotifys();
  } else {
    clear_has_targetsnotifys();
  }
}

// -------------------------------------------------------------------

// UserOnlineInfo

// required uint32 uAccountID = 1 [default = 0];
inline bool UserOnlineInfo::has_uaccountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOnlineInfo::set_has_uaccountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOnlineInfo::clear_has_uaccountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOnlineInfo::clear_uaccountid() {
  uaccountid_ = 0u;
  clear_has_uaccountid();
}
inline ::google::protobuf::uint32 UserOnlineInfo::uaccountid() const {
  return uaccountid_;
}
inline void UserOnlineInfo::set_uaccountid(::google::protobuf::uint32 value) {
  set_has_uaccountid();
  uaccountid_ = value;
}

// required uint32 uLoginFlag = 2 [default = 0];
inline bool UserOnlineInfo::has_uloginflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOnlineInfo::set_has_uloginflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOnlineInfo::clear_has_uloginflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOnlineInfo::clear_uloginflag() {
  uloginflag_ = 0u;
  clear_has_uloginflag();
}
inline ::google::protobuf::uint32 UserOnlineInfo::uloginflag() const {
  return uloginflag_;
}
inline void UserOnlineInfo::set_uloginflag(::google::protobuf::uint32 value) {
  set_has_uloginflag();
  uloginflag_ = value;
}

// -------------------------------------------------------------------

// LoginInfo

// required string strAccountNo = 1;
inline bool LoginInfo::has_straccountno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginInfo::set_has_straccountno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginInfo::clear_has_straccountno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginInfo::clear_straccountno() {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    straccountno_->clear();
  }
  clear_has_straccountno();
}
inline const ::std::string& LoginInfo::straccountno() const {
  return *straccountno_;
}
inline void LoginInfo::set_straccountno(const ::std::string& value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void LoginInfo::set_straccountno(const char* value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void LoginInfo::set_straccountno(const char* value, size_t size) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_straccountno() {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  return straccountno_;
}
inline ::std::string* LoginInfo::release_straccountno() {
  clear_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccountno_;
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginInfo::set_allocated_straccountno(::std::string* straccountno) {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    delete straccountno_;
  }
  if (straccountno) {
    set_has_straccountno();
    straccountno_ = straccountno;
  } else {
    clear_has_straccountno();
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPasswd = 2;
inline bool LoginInfo::has_strpasswd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginInfo::set_has_strpasswd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginInfo::clear_has_strpasswd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginInfo::clear_strpasswd() {
  if (strpasswd_ != &::google::protobuf::internal::kEmptyString) {
    strpasswd_->clear();
  }
  clear_has_strpasswd();
}
inline const ::std::string& LoginInfo::strpasswd() const {
  return *strpasswd_;
}
inline void LoginInfo::set_strpasswd(const ::std::string& value) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(value);
}
inline void LoginInfo::set_strpasswd(const char* value) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(value);
}
inline void LoginInfo::set_strpasswd(const char* value, size_t size) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_strpasswd() {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  return strpasswd_;
}
inline ::std::string* LoginInfo::release_strpasswd() {
  clear_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpasswd_;
    strpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginInfo::set_allocated_strpasswd(::std::string* strpasswd) {
  if (strpasswd_ != &::google::protobuf::internal::kEmptyString) {
    delete strpasswd_;
  }
  if (strpasswd) {
    set_has_strpasswd();
    strpasswd_ = strpasswd;
  } else {
    clear_has_strpasswd();
    strpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 uLoginFlags = 3 [default = 0];
inline bool LoginInfo::has_uloginflags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginInfo::set_has_uloginflags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginInfo::clear_has_uloginflags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginInfo::clear_uloginflags() {
  uloginflags_ = 0u;
  clear_has_uloginflags();
}
inline ::google::protobuf::uint32 LoginInfo::uloginflags() const {
  return uloginflags_;
}
inline void LoginInfo::set_uloginflags(::google::protobuf::uint32 value) {
  set_has_uloginflags();
  uloginflags_ = value;
}

// -------------------------------------------------------------------

// RegisterInfo

// required string strAccountNo = 1;
inline bool RegisterInfo::has_straccountno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterInfo::set_has_straccountno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterInfo::clear_has_straccountno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterInfo::clear_straccountno() {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    straccountno_->clear();
  }
  clear_has_straccountno();
}
inline const ::std::string& RegisterInfo::straccountno() const {
  return *straccountno_;
}
inline void RegisterInfo::set_straccountno(const ::std::string& value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void RegisterInfo::set_straccountno(const char* value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void RegisterInfo::set_straccountno(const char* value, size_t size) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInfo::mutable_straccountno() {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  return straccountno_;
}
inline ::std::string* RegisterInfo::release_straccountno() {
  clear_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccountno_;
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInfo::set_allocated_straccountno(::std::string* straccountno) {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    delete straccountno_;
  }
  if (straccountno) {
    set_has_straccountno();
    straccountno_ = straccountno;
  } else {
    clear_has_straccountno();
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPasswd = 2;
inline bool RegisterInfo::has_strpasswd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterInfo::set_has_strpasswd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterInfo::clear_has_strpasswd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterInfo::clear_strpasswd() {
  if (strpasswd_ != &::google::protobuf::internal::kEmptyString) {
    strpasswd_->clear();
  }
  clear_has_strpasswd();
}
inline const ::std::string& RegisterInfo::strpasswd() const {
  return *strpasswd_;
}
inline void RegisterInfo::set_strpasswd(const ::std::string& value) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(value);
}
inline void RegisterInfo::set_strpasswd(const char* value) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(value);
}
inline void RegisterInfo::set_strpasswd(const char* value, size_t size) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInfo::mutable_strpasswd() {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  return strpasswd_;
}
inline ::std::string* RegisterInfo::release_strpasswd() {
  clear_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpasswd_;
    strpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInfo::set_allocated_strpasswd(::std::string* strpasswd) {
  if (strpasswd_ != &::google::protobuf::internal::kEmptyString) {
    delete strpasswd_;
  }
  if (strpasswd) {
    set_has_strpasswd();
    strpasswd_ = strpasswd;
  } else {
    clear_has_strpasswd();
    strpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strNickName = 3;
inline bool RegisterInfo::has_strnickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterInfo::set_has_strnickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterInfo::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterInfo::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& RegisterInfo::strnickname() const {
  return *strnickname_;
}
inline void RegisterInfo::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void RegisterInfo::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void RegisterInfo::set_strnickname(const char* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInfo::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* RegisterInfo::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInfo::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfoReq

// required .tms.UserInfoReq.cmd ncmd = 1 [default = UserInfo];
inline bool UserInfoReq::has_ncmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoReq::set_has_ncmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoReq::clear_has_ncmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoReq::clear_ncmd() {
  ncmd_ = 3;
  clear_has_ncmd();
}
inline ::tms::UserInfoReq_cmd UserInfoReq::ncmd() const {
  return static_cast< ::tms::UserInfoReq_cmd >(ncmd_);
}
inline void UserInfoReq::set_ncmd(::tms::UserInfoReq_cmd value) {
  assert(::tms::UserInfoReq_cmd_IsValid(value));
  set_has_ncmd();
  ncmd_ = value;
}

// -------------------------------------------------------------------

// TargetsQuery

// required string strAccountNo = 1;
inline bool TargetsQuery::has_straccountno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetsQuery::set_has_straccountno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetsQuery::clear_has_straccountno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetsQuery::clear_straccountno() {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    straccountno_->clear();
  }
  clear_has_straccountno();
}
inline const ::std::string& TargetsQuery::straccountno() const {
  return *straccountno_;
}
inline void TargetsQuery::set_straccountno(const ::std::string& value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void TargetsQuery::set_straccountno(const char* value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void TargetsQuery::set_straccountno(const char* value, size_t size) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetsQuery::mutable_straccountno() {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  return straccountno_;
}
inline ::std::string* TargetsQuery::release_straccountno() {
  clear_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccountno_;
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetsQuery::set_allocated_straccountno(::std::string* straccountno) {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    delete straccountno_;
  }
  if (straccountno) {
    set_has_straccountno();
    straccountno_ = straccountno;
  } else {
    clear_has_straccountno();
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strNickName = 2;
inline bool TargetsQuery::has_strnickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetsQuery::set_has_strnickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetsQuery::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetsQuery::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& TargetsQuery::strnickname() const {
  return *strnickname_;
}
inline void TargetsQuery::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void TargetsQuery::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void TargetsQuery::set_strnickname(const char* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetsQuery::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* TargetsQuery::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetsQuery::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UpdateUserInfo

// optional string strNickName = 1;
inline bool UpdateUserInfo::has_strnickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserInfo::set_has_strnickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserInfo::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserInfo::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& UpdateUserInfo::strnickname() const {
  return *strnickname_;
}
inline void UpdateUserInfo::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UpdateUserInfo::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UpdateUserInfo::set_strnickname(const char* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateUserInfo::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* UpdateUserInfo::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateUserInfo::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nFace = 2 [default = 0];
inline bool UpdateUserInfo::has_nface() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserInfo::set_has_nface() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserInfo::clear_has_nface() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserInfo::clear_nface() {
  nface_ = 0u;
  clear_has_nface();
}
inline ::google::protobuf::uint32 UpdateUserInfo::nface() const {
  return nface_;
}
inline void UpdateUserInfo::set_nface(::google::protobuf::uint32 value) {
  set_has_nface();
  nface_ = value;
}

// optional .tms.UserPrivateInfo PrivateInfos = 3;
inline bool UpdateUserInfo::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateUserInfo::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateUserInfo::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateUserInfo::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::UserPrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::UserPrivateInfo& UpdateUserInfo::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::UserPrivateInfo* UpdateUserInfo::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::UserPrivateInfo;
  return privateinfos_;
}
inline ::tms::UserPrivateInfo* UpdateUserInfo::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::UserPrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void UpdateUserInfo::set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// -------------------------------------------------------------------

// TargetsAdd

// required uint32 uTargetID = 1 [default = 0];
inline bool TargetsAdd::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetsAdd::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetsAdd::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetsAdd::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 TargetsAdd::utargetid() const {
  return utargetid_;
}
inline void TargetsAdd::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required .tms.TargetsAdd.cmd ncmd = 2 [default = Apply];
inline bool TargetsAdd::has_ncmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetsAdd::set_has_ncmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetsAdd::clear_has_ncmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetsAdd::clear_ncmd() {
  ncmd_ = 0;
  clear_has_ncmd();
}
inline ::tms::TargetsAdd_cmd TargetsAdd::ncmd() const {
  return static_cast< ::tms::TargetsAdd_cmd >(ncmd_);
}
inline void TargetsAdd::set_ncmd(::tms::TargetsAdd_cmd value) {
  assert(::tms::TargetsAdd_cmd_IsValid(value));
  set_has_ncmd();
  ncmd_ = value;
}

// -------------------------------------------------------------------

// UpdateTargetInfo

// required uint32 uTargetID = 1 [default = 0];
inline bool UpdateTargetInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTargetInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTargetInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTargetInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 UpdateTargetInfo::utargetid() const {
  return utargetid_;
}
inline void UpdateTargetInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// optional string strNickName = 2;
inline bool UpdateTargetInfo::has_strnickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTargetInfo::set_has_strnickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTargetInfo::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTargetInfo::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& UpdateTargetInfo::strnickname() const {
  return *strnickname_;
}
inline void UpdateTargetInfo::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UpdateTargetInfo::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UpdateTargetInfo::set_strnickname(const char* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateTargetInfo::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* UpdateTargetInfo::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateTargetInfo::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes selfparam = 3;
inline bool UpdateTargetInfo::has_selfparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateTargetInfo::set_has_selfparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateTargetInfo::clear_has_selfparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateTargetInfo::clear_selfparam() {
  if (selfparam_ != &::google::protobuf::internal::kEmptyString) {
    selfparam_->clear();
  }
  clear_has_selfparam();
}
inline const ::std::string& UpdateTargetInfo::selfparam() const {
  return *selfparam_;
}
inline void UpdateTargetInfo::set_selfparam(const ::std::string& value) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(value);
}
inline void UpdateTargetInfo::set_selfparam(const char* value) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(value);
}
inline void UpdateTargetInfo::set_selfparam(const void* value, size_t size) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateTargetInfo::mutable_selfparam() {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  return selfparam_;
}
inline ::std::string* UpdateTargetInfo::release_selfparam() {
  clear_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfparam_;
    selfparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateTargetInfo::set_allocated_selfparam(::std::string* selfparam) {
  if (selfparam_ != &::google::protobuf::internal::kEmptyString) {
    delete selfparam_;
  }
  if (selfparam) {
    set_has_selfparam();
    selfparam_ = selfparam;
  } else {
    clear_has_selfparam();
    selfparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfoNotify

// required uint32 uAccountID = 1 [default = 0];
inline bool UserInfoNotify::has_uaccountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoNotify::set_has_uaccountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoNotify::clear_has_uaccountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoNotify::clear_uaccountid() {
  uaccountid_ = 0u;
  clear_has_uaccountid();
}
inline ::google::protobuf::uint32 UserInfoNotify::uaccountid() const {
  return uaccountid_;
}
inline void UserInfoNotify::set_uaccountid(::google::protobuf::uint32 value) {
  set_has_uaccountid();
  uaccountid_ = value;
}

// optional string strAccountNo = 2;
inline bool UserInfoNotify::has_straccountno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoNotify::set_has_straccountno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoNotify::clear_has_straccountno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoNotify::clear_straccountno() {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    straccountno_->clear();
  }
  clear_has_straccountno();
}
inline const ::std::string& UserInfoNotify::straccountno() const {
  return *straccountno_;
}
inline void UserInfoNotify::set_straccountno(const ::std::string& value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void UserInfoNotify::set_straccountno(const char* value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void UserInfoNotify::set_straccountno(const char* value, size_t size) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoNotify::mutable_straccountno() {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  return straccountno_;
}
inline ::std::string* UserInfoNotify::release_straccountno() {
  clear_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccountno_;
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoNotify::set_allocated_straccountno(::std::string* straccountno) {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    delete straccountno_;
  }
  if (straccountno) {
    set_has_straccountno();
    straccountno_ = straccountno;
  } else {
    clear_has_straccountno();
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strNickName = 3;
inline bool UserInfoNotify::has_strnickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoNotify::set_has_strnickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoNotify::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoNotify::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& UserInfoNotify::strnickname() const {
  return *strnickname_;
}
inline void UserInfoNotify::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UserInfoNotify::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UserInfoNotify::set_strnickname(const char* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoNotify::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* UserInfoNotify::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoNotify::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nFace = 4 [default = 0];
inline bool UserInfoNotify::has_nface() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoNotify::set_has_nface() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoNotify::clear_has_nface() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoNotify::clear_nface() {
  nface_ = 0u;
  clear_has_nface();
}
inline ::google::protobuf::uint32 UserInfoNotify::nface() const {
  return nface_;
}
inline void UserInfoNotify::set_nface(::google::protobuf::uint32 value) {
  set_has_nface();
  nface_ = value;
}

// optional .tms.UserPrivateInfo PrivateInfos = 5;
inline bool UserInfoNotify::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfoNotify::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfoNotify::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfoNotify::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::UserPrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::UserPrivateInfo& UserInfoNotify::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfoNotify::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::UserPrivateInfo;
  return privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfoNotify::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::UserPrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void UserInfoNotify::set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// -------------------------------------------------------------------

// TargetsAddNotify

// required .tms.TargetsAdd TargetsAdds = 1;
inline bool TargetsAddNotify::has_targetsadds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetsAddNotify::set_has_targetsadds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetsAddNotify::clear_has_targetsadds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetsAddNotify::clear_targetsadds() {
  if (targetsadds_ != NULL) targetsadds_->::tms::TargetsAdd::Clear();
  clear_has_targetsadds();
}
inline const ::tms::TargetsAdd& TargetsAddNotify::targetsadds() const {
  return targetsadds_ != NULL ? *targetsadds_ : *default_instance_->targetsadds_;
}
inline ::tms::TargetsAdd* TargetsAddNotify::mutable_targetsadds() {
  set_has_targetsadds();
  if (targetsadds_ == NULL) targetsadds_ = new ::tms::TargetsAdd;
  return targetsadds_;
}
inline ::tms::TargetsAdd* TargetsAddNotify::release_targetsadds() {
  clear_has_targetsadds();
  ::tms::TargetsAdd* temp = targetsadds_;
  targetsadds_ = NULL;
  return temp;
}
inline void TargetsAddNotify::set_allocated_targetsadds(::tms::TargetsAdd* targetsadds) {
  delete targetsadds_;
  targetsadds_ = targetsadds;
  if (targetsadds) {
    set_has_targetsadds();
  } else {
    clear_has_targetsadds();
  }
}

// required .tms.TargetInfo TargetInfos = 3;
inline bool TargetsAddNotify::has_targetinfos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetsAddNotify::set_has_targetinfos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetsAddNotify::clear_has_targetinfos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetsAddNotify::clear_targetinfos() {
  if (targetinfos_ != NULL) targetinfos_->::tms::TargetInfo::Clear();
  clear_has_targetinfos();
}
inline const ::tms::TargetInfo& TargetsAddNotify::targetinfos() const {
  return targetinfos_ != NULL ? *targetinfos_ : *default_instance_->targetinfos_;
}
inline ::tms::TargetInfo* TargetsAddNotify::mutable_targetinfos() {
  set_has_targetinfos();
  if (targetinfos_ == NULL) targetinfos_ = new ::tms::TargetInfo;
  return targetinfos_;
}
inline ::tms::TargetInfo* TargetsAddNotify::release_targetinfos() {
  clear_has_targetinfos();
  ::tms::TargetInfo* temp = targetinfos_;
  targetinfos_ = NULL;
  return temp;
}
inline void TargetsAddNotify::set_allocated_targetinfos(::tms::TargetInfo* targetinfos) {
  delete targetinfos_;
  targetinfos_ = targetinfos;
  if (targetinfos) {
    set_has_targetinfos();
  } else {
    clear_has_targetinfos();
  }
}

// -------------------------------------------------------------------

// TargetsNotify

// repeated .tms.Targets Targetss = 1;
inline int TargetsNotify::targetss_size() const {
  return targetss_.size();
}
inline void TargetsNotify::clear_targetss() {
  targetss_.Clear();
}
inline const ::tms::Targets& TargetsNotify::targetss(int index) const {
  return targetss_.Get(index);
}
inline ::tms::Targets* TargetsNotify::mutable_targetss(int index) {
  return targetss_.Mutable(index);
}
inline ::tms::Targets* TargetsNotify::add_targetss() {
  return targetss_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::Targets >&
TargetsNotify::targetss() const {
  return targetss_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::Targets >*
TargetsNotify::mutable_targetss() {
  return &targetss_;
}

// -------------------------------------------------------------------

// UserOnlineNotify

// required uint32 uAccountID = 1 [default = 0];
inline bool UserOnlineNotify::has_uaccountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOnlineNotify::set_has_uaccountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOnlineNotify::clear_has_uaccountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOnlineNotify::clear_uaccountid() {
  uaccountid_ = 0u;
  clear_has_uaccountid();
}
inline ::google::protobuf::uint32 UserOnlineNotify::uaccountid() const {
  return uaccountid_;
}
inline void UserOnlineNotify::set_uaccountid(::google::protobuf::uint32 value) {
  set_has_uaccountid();
  uaccountid_ = value;
}

// required uint32 uServerID = 2 [default = 0];
inline bool UserOnlineNotify::has_userverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOnlineNotify::set_has_userverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOnlineNotify::clear_has_userverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOnlineNotify::clear_userverid() {
  userverid_ = 0u;
  clear_has_userverid();
}
inline ::google::protobuf::uint32 UserOnlineNotify::userverid() const {
  return userverid_;
}
inline void UserOnlineNotify::set_userverid(::google::protobuf::uint32 value) {
  set_has_userverid();
  userverid_ = value;
}

// required uint32 uLoginFlag = 3 [default = 0];
inline bool UserOnlineNotify::has_uloginflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserOnlineNotify::set_has_uloginflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserOnlineNotify::clear_has_uloginflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserOnlineNotify::clear_uloginflag() {
  uloginflag_ = 0u;
  clear_has_uloginflag();
}
inline ::google::protobuf::uint32 UserOnlineNotify::uloginflag() const {
  return uloginflag_;
}
inline void UserOnlineNotify::set_uloginflag(::google::protobuf::uint32 value) {
  set_has_uloginflag();
  uloginflag_ = value;
}

// -------------------------------------------------------------------

// UserLoginFlag

// required uint32 uAccountID = 1 [default = 0];
inline bool UserLoginFlag::has_uaccountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginFlag::set_has_uaccountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginFlag::clear_has_uaccountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginFlag::clear_uaccountid() {
  uaccountid_ = 0u;
  clear_has_uaccountid();
}
inline ::google::protobuf::uint32 UserLoginFlag::uaccountid() const {
  return uaccountid_;
}
inline void UserLoginFlag::set_uaccountid(::google::protobuf::uint32 value) {
  set_has_uaccountid();
  uaccountid_ = value;
}

// required uint32 uLoginFlags = 2 [default = 0];
inline bool UserLoginFlag::has_uloginflags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginFlag::set_has_uloginflags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginFlag::clear_has_uloginflags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginFlag::clear_uloginflags() {
  uloginflags_ = 0u;
  clear_has_uloginflags();
}
inline ::google::protobuf::uint32 UserLoginFlag::uloginflags() const {
  return uloginflags_;
}
inline void UserLoginFlag::set_uloginflags(::google::protobuf::uint32 value) {
  set_has_uloginflags();
  uloginflags_ = value;
}

// -------------------------------------------------------------------

// UserLoginFlagList

// repeated .tms.UserLoginFlag UserLoginFlags = 1;
inline int UserLoginFlagList::userloginflags_size() const {
  return userloginflags_.size();
}
inline void UserLoginFlagList::clear_userloginflags() {
  userloginflags_.Clear();
}
inline const ::tms::UserLoginFlag& UserLoginFlagList::userloginflags(int index) const {
  return userloginflags_.Get(index);
}
inline ::tms::UserLoginFlag* UserLoginFlagList::mutable_userloginflags(int index) {
  return userloginflags_.Mutable(index);
}
inline ::tms::UserLoginFlag* UserLoginFlagList::add_userloginflags() {
  return userloginflags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::UserLoginFlag >&
UserLoginFlagList::userloginflags() const {
  return userloginflags_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::UserLoginFlag >*
UserLoginFlagList::mutable_userloginflags() {
  return &userloginflags_;
}

// -------------------------------------------------------------------

// ChatUser

// required uint32 uAccountID = 1 [default = 0];
inline bool ChatUser::has_uaccountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatUser::set_has_uaccountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatUser::clear_has_uaccountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatUser::clear_uaccountid() {
  uaccountid_ = 0u;
  clear_has_uaccountid();
}
inline ::google::protobuf::uint32 ChatUser::uaccountid() const {
  return uaccountid_;
}
inline void ChatUser::set_uaccountid(::google::protobuf::uint32 value) {
  set_has_uaccountid();
  uaccountid_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool ChatUser::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatUser::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatUser::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatUser::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 ChatUser::utargetid() const {
  return utargetid_;
}
inline void ChatUser::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required uint32 uRight = 3 [default = 0];
inline bool ChatUser::has_uright() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatUser::set_has_uright() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatUser::clear_has_uright() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatUser::clear_uright() {
  uright_ = 0u;
  clear_has_uright();
}
inline ::google::protobuf::uint32 ChatUser::uright() const {
  return uright_;
}
inline void ChatUser::set_uright(::google::protobuf::uint32 value) {
  set_has_uright();
  uright_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tms

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tms::UserInfoReq_cmd>() {
  return ::tms::UserInfoReq_cmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tms::TargetsAdd_cmd>() {
  return ::tms::TargetsAdd_cmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tms::OnlineState>() {
  return ::tms::OnlineState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
